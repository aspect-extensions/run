"""Utility to execute bazel-built binaries

Expected to be used to replace the 'bazel run' command.
"""

load("./runnable.axl", "runnable")

def _run_impl(ctx):
    out = ctx.std.io.stdout
    err = ctx.std.io.stderr
    targets = ctx.args.target

    if len(targets) == 0:
        err.write("INFO: No targets specified, finding the default target.\n")
        target_set = ctx.bazel.query().raw("attr(tags, '\\bdefault_run\\b', //...)").eval()
        if len(target_set) == 0:
            err.write("\x1b[0;31mERROR\x1b[0m: No default targets found.\n")
            return 1
        elif len(target_set) > 1:
            err.write("Multiple default targets found.")
            return 1
        targets = [str(target_set[0])]
        err.write("\x1b[0;32mINFO\x1b[0m: Found the default target: %s\n" % targets[0])
        err.flush()

    if len(targets) > 1:
        err.write("Multiple targets are not supported yet. Coming soon.")

    build = ctx.bazel.build(
        events = True,
        bazel_flags = [
            "--isatty=" + str(int(out.is_tty)),
            # need the runfiles directory.
            "--build_runfile_links",
        ],
        *targets,
    )
    run = runnable(ctx, targets)
    for event in build.events():
        if event.kind == "progress":
            out.write(event.payload.stdout)
            err.write(event.payload.stderr)
        else:
            # pass event for runnable to find the entrypoint
            run.event(event)

    entrypoint = run.determine_entrypoint(targets[0])

    if not entrypoint:
        err.write("Could not determine the binary entry point.")
        return 1

    err.write("\x1b[F\x1b[0;32mINFO\x1b[0m: Running: \x1b[1;97m%s\x1b[0m\n" % entrypoint[entrypoint.find("bazel-out"):])
    err.write("\n")
    err.flush()

    exit = run.spawn(entrypoint, ctx.args.varargs).wait()

    if not exit.success:
        err.write("\x1b[0;31mERROR\x1b[0m: process exited with code %d\n" % exit.code)

    return exit.code

run = task(
    implementation = _run_impl,
    args = {
        "target": args.positional(),
        "varargs": args.trailing_var_args()
    }
)
