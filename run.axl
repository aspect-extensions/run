"""Utility to execute bazel-built binaries

Expected to be used to replace the 'bazel run' command.
"""

load("./runnable.axl", "runnable")

def spawn(ctx: task_context, entrypoint: str, args: list[str]) -> std.process.child:
    """Execute a program that was built by Bazel.

    - Set the environment required for commonly understood language-specific Runfiles libraries
    - Set BUILD_WORKING_DIRECTORY and BUILD_WORKSPACE_DIRECTORY like Bazel does

    TODO: set the env and args that the *_binary target specifies

    Args:
      ctx: AXL task context
      entrypoint: relative path to the executable, typically under bazel-bin

    """
    runfiles = entrypoint + ".runfiles"
    return ctx.std.process.command(entrypoint)\
        .current_dir(runfiles) \
        .env("RUNFILES_DIR", runfiles) \
        .env("JAVA_RUNFILES", runfiles) \
        .env("RUNFILES_MANIFEST_FILE", runfiles + "_manifest") \
        .env("BUILD_WORKSPACE_DIRECTORY", "TODO") \
        .env("BUILD_WORKING_DIRECTORY", ctx.std.env.current_dir()) \
        .args(args) \
        .spawn()

def _run_impl(ctx):
    out = ctx.std.io.stdout
    targets = ctx.args.target

    if len(targets) == 0:
        out.write("INFO: No targets specified, finding the default target.\n")
        target_set = ctx.bazel.query().raw("attr(tags, '\\bdefault_run\\b', //...)").eval()
        if len(target_set) == 0:
            out.write("\x1b[0;31mERROR\x1b[0m: No default targets found.\n")
            return 1
        elif len(target_set) > 1:
            out.write("Multiple default targets found.")
            return 1
        targets = [str(target_set[0])]
        out.write("\x1b[0;32mINFO\x1b[0m: Found the default target: %s\n" % targets[0])
        out.flush()

    if len(targets) > 1:
        out.write("Multiple targets are not supported yet. Coming soon.")


    build = ctx.bazel.build(
        events = True,
        bazel_flags = [
            "--isatty=" + str(int(out.is_tty)),
            # need the runfiles directory.
            "--build_runfile_links",
        ],
        *targets,
    )
    run = runnable(ctx, targets)
    for event in build.events():
        if event.type == "progress":
            out.write(event.payload.stdout)
            out.write(event.payload.stderr)
        else:
            # pass event for runnable to find the entrypoint
            run.event(event)

    entrypoint = run.determine_entrypoint(targets[0])

    if not entrypoint:
        out.write("Could not determine the binary entry point.")
        return 1

    out.write("\x1b[F\x1b[0;32mINFO\x1b[0m: Running: \x1b[1;97m%s\x1b[0m\n" % entrypoint[entrypoint.find("bazel-out"):])
    out.write("\n")
    out.flush()

    exit = run.spawn(entrypoint, ctx.args.varargs).wait()

    if not exit.success:
        out.write("\x1b[0;31mERROR\x1b[0m: process exited with code %d\n" % exit.code)

    return exit.code

run = task(
    implementation = _run_impl,
    args = {
        "target": args.positional(),
        "varargs": args.trailing_var_args()
    }
)
