def _process_bes(state: struct, event: bazel.build.build_event.BuildEvent):
    filesets = state.filesets
    target_fileset = state.target_fileset
    targets = state.targets
    if event.kind == "named_set_of_files":
        filesets[event.id.id] = event.payload.files
    elif event.kind == "target_completed":
        if event.id.label in targets:
            for og in event.payload.output_group:
                if og.name == "default":
                    target_fileset[event.id.label] = og.file_sets

def _determine_entrypoint(state: struct, target: str) -> str | None:
    filesets = state.filesets
    target_fileset = state.target_fileset
    if target not in target_fileset:
        return None
    targetfs = target_fileset[target][0].id
    files = filesets[targetfs]
    entrypoint = None
    for file in files:
        if len(file.path_prefix):
            entrypoint = file.file.removeprefix("file://")
            break
    return entrypoint

def _spawn(ctx: task_context, entrypoint: str, args: list[str]) -> std.process.child:
    """Execute a program that was built by Bazel.

    - Set the environment required for commonly understood language-specific Runfiles libraries
    - Set BUILD_WORKING_DIRECTORY and BUILD_WORKSPACE_DIRECTORY like Bazel does

    TODO: set the env and args that the *_binary target specifies

    Args:
      ctx: AXL task context
      entrypoint: relative path to the executable, typically under bazel-bin
      args: list of arguments to pass to the executable
    """
    runfiles = entrypoint + ".runfiles"
    return ctx.std.process.command(entrypoint)\
        .current_dir(runfiles) \
        .env("RUNFILES_DIR", runfiles) \
        .env("JAVA_RUNFILES", runfiles) \
        .env("RUNFILES_MANIFEST_FILE", runfiles + "_manifest") \
        .env("BUILD_WORKSPACE_DIRECTORY", "TODO") \
        .env("BUILD_WORKING_DIRECTORY", ctx.std.env.current_dir()) \
        .args(args) \
        .spawn()


def _as_spawn(ctx: task_context, target: str, entrypoint: str, args: list[str]) -> list[str]:
    runfiles = entrypoint + ".runfiles"
    spawn = [
        "--spawn",
        entrypoint,
        "--title",
        target,
        "--current_dir",
        runfiles,
        "--env",
        "RUNFILES_DIR=%s" % runfiles,
        "--env",
        "JAVA_RUNFILES=%s" % runfiles,
        "--env",
        "RUNFILES_MANIFEST_FILE=%s_manifest" % runfiles,
        "--env",
        "BUILD_WORKSPACE_DIRECTORY=TODO",
        "--env",
        "BUILD_WORKING_DIRECTORY=%s" % ctx.std.env.current_dir(),
    ]
    for arg in args:
        spawn.add("--arg")
        spawn.add(arg)
    return spawn

def _uname(ctx) -> str:
    raw = ctx.std.process.command("uname").stdout("piped").arg("-ms").spawn().wait_with_output().stdout
    (os, arch) = raw.split(" ", 1)
    return "{}-{}".format(
        arch.strip().replace("arm64", "aarch64"),
        os.lower().replace("darwin", "apple-darwin").replace("linux", "unknown-linux-gnu")
    )

def _spawn_mux(ctx: task_context, args: list[str]) -> std.process.child:
    if not ctx.std.fs.exists("/tmp/pty-multiplex"):
        ctx.http().download(
            url = "https://github.com/aspect-extensions/run/releases/download/v0.1.1/pty-multiplex-" + _uname(ctx),
            output = "/tmp/pty-multiplex",
            mode = 0o777
        ).block()
    return ctx.std.process.command("/tmp/pty-multiplex") \
        .args(args) \
        .spawn()

def runnable(ctx, targets: list[str]) -> struct:
    state = struct(
        ctx = ctx,
        targets = targets,
        filesets = {},
        target_fileset = {}
    )

    return struct(
        event = lambda event: _process_bes(state, event),
        determine_entrypoint = lambda event: _determine_entrypoint(state, event),
        spawn = lambda entrypoint, args: _spawn(ctx, entrypoint, args),
        as_spawn_mux = lambda title, entrypoint, args: _as_spawn(ctx, title, entrypoint, args),
        spawn_mux = lambda args: _spawn_mux(ctx, args)
    )

spawn = _spawn
